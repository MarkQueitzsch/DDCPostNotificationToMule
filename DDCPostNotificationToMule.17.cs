// Skeleton generated by Hyland Unity Editor on 8/11/2023 1:37:45 PM
namespace DDCPostNotificationToMule
{
    using System;
    using System.Text;
    using System.IO;
    using System.Xml;
    using System.Net;

    using Hyland.Unity;
    using Hyland.Unity.Extensions;
    using Hyland.Unity.Upop;
    using Hyland.Unity.Workflow;

    /// <summary>
    /// DDCPostNotificationToMule
    /// </summary>
    public class DDCPostNotificationToMule : Hyland.Unity.IWorkflowScript
    {
        #region IWorkflowScript

        const string SCRIPT_NAME = "DDCPostNotificationToMule";
        private const string STR_CONST_DOCDATE = "docDate";
        private const string STR_CONST_DOCTYPE = "docTypeName";
        private const string STR_CONST_DOCHANDLE = "documentHandle";
        private const string PROP_MULE_EVENT_NAME = "pMuleEventName";

        private const string DDC_MULE_MDR_NOTIFY_URL = "DDC_MULE_MDR_NOTIFY_URL";

        private string strError = null;

        private string STRTRANSACTIONID = DateTime.Now.Ticks.ToString();
        private string STRDOCDATE = DateTime.Now.ToString("yyyy-MM-dd");
        private string STRDOCTYPE = "outbound";
        private string STRSCHEMAVERSION = "v1";
        private string STRMULEEVENTNAME = string.Empty; //"LightTouchGenericDocumentEvent";
        private const string PROP_ERROR = "SCRIPT_ERROR";
        private const string PROP_REQUEST_DIRECTIVE = "pRequestDirective";

        private Hyland.Unity.WorkflowEventArgs _args { get; set; }

        /// <summary>
        /// Implementation of <see cref="ISchedulableScript.OnExecute" />.
        /// <seealso cref="ISchedulableScript" />
        /// </summary>
        /// <param name="app"></param>
        /// <param name="args"></param>
        public void OnWorkflowScriptExecute(Hyland.Unity.Application app, Hyland.Unity.WorkflowEventArgs args)
        {
            app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Verbose, $"{SCRIPT_NAME}: entered method.");

            _args = args;

            args.ScriptResult = false;

            try
            {
                if (!args.PropertyBag.TryGetValue(PROP_MULE_EVENT_NAME, out STRMULEEVENTNAME))
                {
                    throw new Exception($"{SCRIPT_NAME}: Scoped workflow property {PROP_MULE_EVENT_NAME} not found.");
                }

                ProcessRequest(app, args);
                args.ScriptResult = true;
            }
            catch (Exception ex)
            {
                app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Error, ex);
                args.PropertyBag.Set(PROP_ERROR, ex.Message);
            }
            app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Verbose, $"{SCRIPT_NAME}: ended method.");
        }
        #endregion

        #region helpermethods

        private string GetKeywordValue(Document doc, KeywordType keytype)
        {
            //Initialize the return value
            string keyvalue = null;

            foreach (KeywordRecord kr in doc.KeywordRecords.FindAll(keytype))
            {
                //Only pulls the first value
                keyvalue = kr.Keywords.Find(keytype).Value.ToString();
            }

            return keyvalue;
        }

        /**
        This method to process the request for specific queue.
        **/

        private string ProcessRequest(Application app, WorkflowEventArgs args)
        {
            try
            {
                string STRCHANNEL = GetKeywordValue(args.Document, app.Core.KeywordTypes.Find("DDC - Channel"));
				if (STRCHANNEL == null)
				{
					STRCHANNEL = GetKeywordValue(args.Document, app.Core.KeywordTypes.Find("Channel"));
				}
                string STRPROCESSID = GetKeywordValue(args.Document, app.Core.KeywordTypes.Find("DDC - Process ID"));
				if (STRPROCESSID == null)
				{
					STRPROCESSID = GetKeywordValue(args.Document, app.Core.KeywordTypes.Find("Process ID"));
				}
                string STRSOURCESYSTEM = GetKeywordValue(args.Document, app.Core.KeywordTypes.Find("INS_SourceSystem"));

                // build Json content
                string outjson = "{\"data\":  {\"type\": \"" + STRMULEEVENTNAME + "\", \"id\": \"" + STRTRANSACTIONID + "\",\"attributes\": { \"channel\": \"" + STRCHANNEL + "\",\"processId\": \"" + STRPROCESSID + "\",\"sourceSystem\": \"" + STRSOURCESYSTEM + "\",";
				
				string xmlPayload = CreateXMLMessage(app, args).InnerXml;
				
                string base64_soapResult =
                    Convert.ToBase64String(Encoding.UTF8.GetBytes(xmlPayload));

                app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Verbose, $"{SCRIPT_NAME}: ProcessRequest: DDC Mule XML: {xmlPayload}.");

                outjson = ConstructJSON(outjson, base64_soapResult, STRDOCDATE,
                    STRDOCTYPE, STRSCHEMAVERSION, app);

                app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Verbose, $"{SCRIPT_NAME}: ProcessRequest: DDC Mule JSON: {outjson}.");

                // notify Mule after successful document retrieval and upload to S3.
                NotifyMuleSoft(outjson, app);
            }
            catch (Exception ex)
            {
                app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Error, ex);
                strError = UpdateMessage(strError, " ProcessRequest : " + ex.Message);
                throw ex;
            }
            return "ProcessRequest complete";
        }

        /**
        Method to construct the JSON string for the REST notification call
        **/
        private string ConstructJSON(string outjson, string base64_notifcationxml,
           string docdate, string doctype, string schemaVersion, Hyland.Unity.Application app)
        {
            app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Verbose, $"{SCRIPT_NAME}: started ConstructJSON method.");

            string tempoutjson = null;

            try
            {
                tempoutjson = outjson
                    + "\"docDate\": \"" + docdate
                    + "\",\"docType\": \"" + doctype
                    + "\", \"schemaVersion\": \"" + schemaVersion
                    + "\",\"rawData\": \"" + base64_notifcationxml
                    + "\"}}}";
            }
            catch (Exception ex)
            {
                app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Error, ex);
                strError = UpdateMessage(strError, "Construct JSON: " + ex.Message);
                throw ex;
            }
            app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Verbose, $"{SCRIPT_NAME}: ended ConstructJSON method.");
            return tempoutjson;
        }

        /**
        This method to notify Mulesoft 
        **/
        private void NotifyMuleSoft(string jsonContent, Hyland.Unity.Application app)
        {
            app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Verbose, $"{SCRIPT_NAME}: NotifyMuleSoft: started method.");

            string mulenotifyURL;
            app.Configuration.TryGetValue(DDC_MULE_MDR_NOTIFY_URL, out mulenotifyURL);

            try
            {
                HttpWebRequest httpRequest = WebRequest.Create(mulenotifyURL) as HttpWebRequest;

                httpRequest.Method = "POST";
                httpRequest.ContentType = "application/vnd.api+json";
                httpRequest.ContentLength = jsonContent.Length;
                //httpRequest.Host = "sit.private-nonprod.icare.nsw.gov.au";

                httpRequest.Headers.Add("X-TrackingID", STRTRANSACTIONID);
                httpRequest.Headers.Add("X-InitialSystem", "OnBase");

                System.Text.UTF8Encoding encoding = new System.Text.UTF8Encoding();
                Byte[] byteArray = encoding.GetBytes(jsonContent);

                app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Verbose, $"{SCRIPT_NAME}: NotifyMuleSoft: Begin adding jsonContent.");

                using (Stream dataStream = httpRequest.GetRequestStream())
                {
                    dataStream.Write(byteArray, 0, byteArray.Length);
                }

                app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Verbose, $"{SCRIPT_NAME}: NotifyMuleSoft: Finished adding jsonContent.");
                app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Verbose, $"{SCRIPT_NAME}: NotifyMuleSoft: Calling Mule REST service," +
                    $" the endpoint from configuration is {mulenotifyURL}.");

                long length = 0;

                string requestDirective = string.Empty;
                if (_args.PropertyBag.TryGetValue(PROP_REQUEST_DIRECTIVE, out requestDirective))
                {
                    switch (requestDirective)
                    {
                        case "NOMAKE_SUCCESS":
                            break;

                        case "NOMAKE_EXCEPTION":
                            throw new Exception($"{SCRIPT_NAME}: DEBUG. Terminated before making POST request.");

                        default:
                            using (HttpWebResponse response = (HttpWebResponse)httpRequest.GetResponse())
                            {
								StreamReader reader = new StreamReader(response.GetResponseStream());
								string responseText = reader.ReadToEnd();
								app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Verbose, $"{SCRIPT_NAME}: Response: {responseText}.");
								
                                length = response.ContentLength;

                                app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Verbose, $"{SCRIPT_NAME}: NotifyMuleSoft:" +
                                    $" Status Code: {response.StatusDescription}, Status Desc: {response.StatusCode}.");

                                if (response.StatusCode.ToString() == "Accepted")
                                {
                                    app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Verbose, $"{SCRIPT_NAME}: NotifyMuleSoft:" +
                                        $" Mule Notification Successful.");
                                }
                                else
                                {
                                    app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Verbose, $"{SCRIPT_NAME}: NotifyMuleSoft:" +
                                        $" Mule Notification Failure.");
                                }
                            }
                            break;
                    }
                }
                else
                {
                    using (HttpWebResponse response = (HttpWebResponse)httpRequest.GetResponse())
                    {
						StreamReader reader = new StreamReader(response.GetResponseStream());
						string responseText = reader.ReadToEnd();
						app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Verbose, $"{SCRIPT_NAME}: Response: {responseText}.");						

                        length = response.ContentLength;

                        app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Verbose, $"{SCRIPT_NAME}: NotifyMuleSoft:" +
                            $" Status Code: {response.StatusDescription}, Status Desc: {response.StatusCode}.");

                        if (response.StatusCode.ToString() == "Accepted")
                        {
                            app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Verbose, $"{SCRIPT_NAME}: NotifyMuleSoft:" +
                                $" Mule Notification Successful.");
                        }
                        else
                        {
                            app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Verbose, $"{SCRIPT_NAME}: NotifyMuleSoft:" +
                                $" Mule Notification Failure.");
                        }
                    }
                }
            }
            // Greg Defina Add catch web exception and log error response stream.
            catch (WebException ex)
            {
                app.Diagnostics.Write(ex);
                strError = UpdateMessage(strError, "Notify MuleSoft: " + ex.Message);

                app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Verbose, $"{SCRIPT_NAME}: Inside web exception: ");
                using (StreamReader rd = new StreamReader(ex.Response.GetResponseStream()))
                {
                    string faultResult = rd.ReadToEnd();
                    app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Verbose, faultResult);
                }
                throw ex;
            }
            catch (Exception ex)
            {
                app.Diagnostics.Write(ex);
                strError = UpdateMessage(strError, "Notify MuleSoft: " + ex.Message);
                throw ex;
            }
            app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Verbose, $"{SCRIPT_NAME}: NotifyMuleSoft: ended method.");
        }

        /**
        This method to construct the error message to print in diagnostic console
        and to get attached along with the notes to the document in exception queue.
        **/
        private string UpdateMessage(string strError, string message)
        {
            if (strError != null)
            {
                strError = strError + " | " + message;
            }
            else
            {
                strError = message;
            }
            return strError;
        }

        #endregion

        #region soaprequesthelpermethods

        private HttpWebRequest CreateWebRequest(string url, string action)
        {
            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(url);
            webRequest.Headers.Add("SOAPAction", action);
            webRequest.ContentType = "text/xml;charset=\"utf-8\"";
            webRequest.Accept = "text/xml";
            webRequest.Method = "POST";
            return webRequest;
        }

        private XmlDocument CreateSoapEnvelope(string dequeue_req_soap_typeidentifier)
        {
            XmlDocument soapEnvelopeDocument = new XmlDocument();
            soapEnvelopeDocument.LoadXml(@"<soapenv:Envelope xmlns:soapenv=""http://schemas.xmlsoap.org/soap/envelope/"" xmlns:v1=""https://icare.onbaseonline.com/icare/WSP/WIClaimsMessageBroker/v1""><soapenv:Header><wsse:Security xmlns:wsse=""http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd"" xmlns:wsu=""http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd""><wsse:UsernameToken wsu:Id=""UsernameToken-2DE4425D5115ACC1C115215011670392""><wsse:Username>WSP_USER</wsse:Username><wsse:Password Type=""http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordText"">password</wsse:Password><wsse:Nonce EncodingType=""http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary"">bRW0+GrUhjv7FReFsESNvQ==</wsse:Nonce><wsu:Created>2018-03-19T23:12:47.038Z</wsu:Created></wsse:UsernameToken></wsse:Security></soapenv:Header><soapenv:Body><v1:" + dequeue_req_soap_typeidentifier + "><v1:InputData><v1:Count>1</v1:Count></v1:InputData></v1:" + dequeue_req_soap_typeidentifier + "></soapenv:Body></soapenv:Envelope>");
            return soapEnvelopeDocument;
        }

        private XmlDocument CreateUpdateMessageSoapEnvelope()
        {
            XmlDocument soapEnvelopeDocument = new XmlDocument();
            //STRTRANSACTIONID = "243432";
            soapEnvelopeDocument.LoadXml(@"<soapenv:Envelope xmlns:soapenv=""http://schemas.xmlsoap.org/soap/envelope/"" xmlns:v1=""https://icare.onbaseonline.com/icare/WSP/WIClaimsMessageBroker/v1""><soapenv:Header><wsse:Security xmlns:wsse=""http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd"" xmlns:wsu=""http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd""><wsse:UsernameToken wsu:Id=""UsernameToken-653465FD9CE573BF3315220263674812""><wsse:Username>WSP_USER</wsse:Username><wsse:Password Type=""http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordText"">password</wsse:Password><wsse:Nonce EncodingType=""http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary"">ZCLZtWyLD3roJbYjpij2lA==</wsse:Nonce><wsu:Created>2018-03-26T01:06:07.481Z</wsu:Created></wsse:UsernameToken></wsse:Security></soapenv:Header><soapenv:Body><v1:UpdateMessageStatus><v1:UpdateMessageData><v1:MessageInstanceNumber>" + STRTRANSACTIONID + "</v1:MessageInstanceNumber><v1:messagePayload/><v1:responseCode>success</v1:responseCode><v1:errorMessage/></v1:UpdateMessageData></v1:UpdateMessageStatus></soapenv:Body></soapenv:Envelope>");
            return soapEnvelopeDocument;
        }

        private void InsertSoapEnvelopeIntoWebRequest(XmlDocument soapEnvelopeXml, HttpWebRequest webRequest)
        {
            using (Stream stream = webRequest.GetRequestStream())
            {
                soapEnvelopeXml.Save(stream);
            }
        }

        #endregion

        #region XML Document Creation

        private XmlDocument CreateXMLMessage(Application app, WorkflowEventArgs args)
        {
            app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Verbose, $"{SCRIPT_NAME}: CreateXMLMessage: started method.");

            XmlDocument doc = new XmlDocument();
            XmlNode docNode = doc.CreateXmlDeclaration("1.0", "UTF-8", null);
            doc.AppendChild(docNode);

            XmlNode msgdataNode = doc.CreateElement("MessageData");
            doc.AppendChild(msgdataNode);

            XmlNode msgnumberNode = doc.CreateElement("MessageInstanceNumber");
            string msgnumber = args.Document.ID.ToString(); //use the notification docid as msgnumber
            msgnumberNode.AppendChild(doc.CreateTextNode(msgnumber));
            msgdataNode.AppendChild(msgnumberNode);

            //connect back to the driving document for message content
            app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Verbose, $"{SCRIPT_NAME}: CreateXMLMessage:" +
                $" Getting doc for message content.");

            KeywordType keytype = app.Core.KeywordTypes.Find("Document Handle");
            string drivingDocHandleString = GetKeywordValue(args.Document, keytype);
            long drivingDocHandle = 0;
            long.TryParse(drivingDocHandleString, out drivingDocHandle);
            Document drivingDoc = app.Core.GetDocumentByID(drivingDocHandle);

            app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Verbose, $"{SCRIPT_NAME}: CreateXMLMessage:" +
                $" Got doc having DocID {drivingDocHandle} for message content.");

            XmlNode msgcontentNode = doc.CreateElement("MessageContent");
            msgdataNode.AppendChild(msgcontentNode);

            XmlNode notifyNode = doc.CreateElement("New_Doc_Notify_Generic_Category_Type");
            msgcontentNode.AppendChild(notifyNode);

            XmlNode docpropsNode = doc.CreateElement("DocumentProperties");
            notifyNode.AppendChild(docpropsNode);

            XmlNode dochandleNode = doc.CreateElement("documentHandle");
            string dochandle = drivingDoc.ID.ToString();
            dochandleNode.AppendChild(doc.CreateTextNode(dochandle));
            docpropsNode.AppendChild(dochandleNode);

            XmlNode docnameNode = doc.CreateElement("docName");
            string docname = drivingDoc.Name.ToString();
            docnameNode.AppendChild(doc.CreateTextNode(docname));
            docpropsNode.AppendChild(docnameNode);

            XmlNode doctypeNode = doc.CreateElement("docTypeName");
            string doctype = drivingDoc.DocumentType.Name.ToString();
            doctypeNode.AppendChild(doc.CreateTextNode(doctype));
            docpropsNode.AppendChild(doctypeNode);
            STRDOCTYPE = doctype;

            XmlNode doctypeNumberNode = doc.CreateElement("docTypeNumber");
            string doctypenumber = drivingDoc.DocumentType.ID.ToString();
            doctypeNumberNode.AppendChild(doc.CreateTextNode(doctypenumber));
            docpropsNode.AppendChild(doctypeNumberNode);

            XmlNode docdateNode = doc.CreateElement("docDate");
            string docdate = drivingDoc.DocumentDate.ToString("yyyy-MM-dd");
            docdateNode.AppendChild(doc.CreateTextNode(docdate));
            docpropsNode.AppendChild(docdateNode);

            XmlNode docdateStoredNode = doc.CreateElement("dateStored");
            string datestored = drivingDoc.DateStored.ToString("yyyy-MM-dd HH:mm:ssZ");
            docdateStoredNode.AppendChild(doc.CreateTextNode(datestored));
            docpropsNode.AppendChild(docdateStoredNode);

            XmlNode docstatusNode = doc.CreateElement("docStatus");
            string docstatus = drivingDoc.Status.ToString();
            docstatusNode.AppendChild(doc.CreateTextNode(docstatus));
            docpropsNode.AppendChild(docstatusNode);

            XmlNode uPopLinkNode = doc.CreateElement("UnityPopLink");
            ShowDocumentGenerator showDocumentGenerator = drivingDoc.Upop().ShowDocumentGenerator();
            string uPopLink = showDocumentGenerator.CreateUpopLink();
            uPopLinkNode.AppendChild(doc.CreateTextNode(uPopLink));
            docpropsNode.AppendChild(uPopLinkNode);

            XmlNode keywordsNode = doc.CreateElement("Keywords");
            notifyNode.AppendChild(keywordsNode);

            XmlNode multiNode = doc.CreateElement("Multi_Instance_Keyword_Group");
            keywordsNode.AppendChild(multiNode);

            XmlNode singleNode = doc.CreateElement("Single_Instance_Keyword_Group");
            keywordsNode.AppendChild(singleNode);

            XmlNode standaloneNode = doc.CreateElement("StandAlone");
            keywordsNode.AppendChild(standaloneNode);

            #region All Keywords
            //2025-01-22 Mark Queitzsch: this region gets keywords from the SYS - Document Notification DDC document 
			//rather than the document it references. I modified it so that it gets keywords from the referenced document
			//rather than the SYS - Document Notification DDC document could be used.
			
			app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Verbose, $"{SCRIPT_NAME}: CreateXMLMessage:" +
			    $" Adding Keywords for DocID: {drivingDoc.ID}.");
			
			RecordType lastRecordType = RecordType.Invalid;
			string lastRecordTypeName = string.Empty;
			
			foreach (KeywordRecord kr in drivingDoc.KeywordRecords)
			{
			    if (lastRecordType != kr.KeywordRecordType.RecordType)
			    {
			        app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Verbose,
			            $"{SCRIPT_NAME}: CreateXMLMessage: Processing keywords of {kr.KeywordRecordType.RecordType.ToString()} Record Type.");
			
			        lastRecordType = kr.KeywordRecordType.RecordType;
			    }
			
			    switch (kr.KeywordRecordType.RecordType)
			    {
			        case RecordType.StandAlone:
			            app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Verbose,
			                $"{SCRIPT_NAME}: CreateXMLMessage: Adding standalone keywords of KT {kr.KeywordRecordType.Name}.");
			
			            string prevKWName = string.Empty;
			
			            foreach (Keyword kw in kr.Keywords)
			            {
			                string kwName = string.Empty;
			                XmlNode kwCollectionNode = null;
			
			                if (kw.KeywordType.Name != prevKWName)
			                {
			                    app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Verbose,
			                        $"{SCRIPT_NAME}: CreateXMLMessage: creating keyword collection for KT {kw.KeywordType.Name}.");
			
			                    kwName = kw.KeywordType.Name.Replace(" ", "").Replace("-", "_");
			                    string kwCollectionName = kwName + "_Collection";
			                    kwCollectionNode = doc.CreateElement(kwCollectionName);
			                    standaloneNode.AppendChild(kwCollectionNode);
			
			                    app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Verbose,
			                        $"{SCRIPT_NAME}: CreateXMLMessage: created {kwCollectionNode.InnerXml} to add {kw.KeywordType.Name} KWs to.");
			
			                    prevKWName = kw.KeywordType.Name;
			                }
			
			                app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Verbose, $"{SCRIPT_NAME}: CreateXMLMessage:" +
			                    $" Adding keyword of KT {kw.KeywordType.Name} to collection.");
			
			                XmlNode kwNode = doc.CreateElement(kwName);
			
			                string kwvalue = null;
			
			                if (kw.KeywordType.DataType == KeywordDataType.Date || kw.KeywordType.DataType == KeywordDataType.DateTime)
			                {
			                    //kwvalue = kw.DateTimeValue.ToString("dd/MM/yyyy");
			                    kwvalue = kw.DateTimeValue.ToString("yyyy-MM-dd");
			                }
			                else
			                {
			                    kwvalue = kw.Value.ToString();
			                }
			                kwNode.AppendChild(doc.CreateTextNode(kwvalue));
			                kwCollectionNode.AppendChild(kwNode);
			
			                app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Verbose, $"{SCRIPT_NAME}: CreateXMLMessage:" +
			                    $" added child element having value {kwNode.InnerXml} to collection.");
			
			            }
			            break;
			
			        case RecordType.SingleInstance:
			            app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Verbose,
			                $"{SCRIPT_NAME}: CreateXMLMessage: Adding standalone keywords of KT {kr.KeywordRecordType.Name}.");
			
			            prevKWName = string.Empty;
			
			            foreach (Keyword kw in kr.Keywords)
			            {
			                string kwName = string.Empty;
			                XmlNode kwCollectionNode = null;
			
			                if (kw.KeywordType.Name != prevKWName)
			                {
			                    app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Verbose,
			                        $"{SCRIPT_NAME}: CreateXMLMessage: creating keyword collection for KT {kw.KeywordType.Name}.");
			
			                    kwName = kw.KeywordType.Name.Replace(" ", "").Replace("-", "_");
			                    string kwCollectionName = kwName + "_Collection";
			                    kwCollectionNode = doc.CreateElement(kwCollectionName);
			                    singleNode.AppendChild(kwCollectionNode);
			
			                    app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Verbose,
			                        $"{SCRIPT_NAME}: CreateXMLMessage: created {kwCollectionNode.InnerXml} to add {kw.KeywordType.Name} KWs to.");
			
			                    prevKWName = kw.KeywordType.Name;
			                }
			
			                app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Verbose, $"{SCRIPT_NAME}: CreateXMLMessage:" +
			                    $" Adding keyword of KT {kw.KeywordType.Name} to collection.");
			
			                XmlNode kwNode = doc.CreateElement(kwName);
			
			                string kwvalue = null;
			
			                if (kw.KeywordType.DataType == KeywordDataType.Date || kw.KeywordType.DataType == KeywordDataType.DateTime)
			                {
			                    //kwvalue = kw.DateTimeValue.ToString("dd/MM/yyyy");
			                    kwvalue = kw.DateTimeValue.ToString("yyyy-MM-dd");
			                }
			                else
			                {
			                    kwvalue = kw.Value.ToString();
			                }
			                kwNode.AppendChild(doc.CreateTextNode(kwvalue));
			                kwCollectionNode.AppendChild(kwNode);
			
			                app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Verbose, $"{SCRIPT_NAME}: CreateXMLMessage:" +
			                    $" added child element having value {kwNode.InnerXml} to collection.");
			
			            }
			            break;
			
			        case RecordType.MultiInstance:
			            app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Verbose,
			                $"{SCRIPT_NAME}: CreateXMLMessage: Processing {kr.KeywordRecordType.Name} Keyword Record.");
			
			            //create a Keyword Record Collection
			            string kwRecordCollection = kr.KeywordRecordType.Name.Replace(" ", "").Replace("-", "_") + "_Collection";
			            XmlNode kwRecordCollectionNode = doc.CreateElement(kwRecordCollection);
			            multiNode.AppendChild(kwRecordCollectionNode);
			            lastRecordTypeName = kr.KeywordRecordType.Name;
			
			            foreach (Keyword kw in kr.Keywords)
			            {
			                string kwName = kw.KeywordType.Name.Replace(" ", "").Replace("-", "_");
			                XmlNode kwNode = doc.CreateElement(kwName);
			
			                string kwvalue = null;
			
			                if (kw.KeywordType.DataType == KeywordDataType.Date || kw.KeywordType.DataType == KeywordDataType.DateTime)
			                {
			                    //kwvalue = kw.DateTimeValue.ToString("dd/MM/yyyy");
			                    kwvalue = kw.DateTimeValue.ToString("yyyy-MM-dd");
			                }
			                else
			                {
			                    kwvalue = kw.Value.ToString();
			                }
			                kwNode.AppendChild(doc.CreateTextNode(kwvalue));
			                kwRecordCollectionNode.AppendChild(kwNode);
			            }
			            break;
			    }
			}
			
			KeywordRecord krMIMEType = drivingDoc.KeywordRecords.Find(app.Core.KeywordTypes.Find("Mime Type"));
			if (krMIMEType != null)
			{
			    string mimetype = krMIMEType.Keywords.Find("Mime Type").AlphaNumericValue;
			    XmlNode mimetypeNode = doc.CreateElement("mimeType");
			    mimetypeNode.AppendChild(doc.CreateTextNode(mimetype));
			    docpropsNode.AppendChild(mimetypeNode);
			}
			
			#endregion
			
			app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Verbose, $"{SCRIPT_NAME}: CreateXMLMessage: XML Message: {doc.InnerXml}.");
			return doc;
        }

        #endregion
    }
}